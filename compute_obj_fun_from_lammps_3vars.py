import numpy as np
from lammps import lammps

# from IPython import embed

def read_params_file(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
        # Extract variables from the lines based on the format
        x1 = float(lines[1].split()[0])
        x2 = float(lines[2].split()[0])
        x3 = float(lines[3].split()[0])
    return x1, x2, x3

def rosenbrock(x1, x2):
    return (1 - x1)**2 + 100 * (x2 - x1**2)**2

def write_results_file(filename, f_val):
    with open(filename, 'w') as f:
        f.write(f'{f_val:.15e} f\n')


def write_pair_potential(c0_, c1_, c2_):
    # Embedding function parameters
    nrho = 5000
    drho = 15 * 0.1664185884538253E-02
    rho = np.arange(0, drho * nrho, drho)
    F_pot = -np.sqrt(rho)

    arr_fs = []

    # Tabulate F_pot
    for jj in range(1000):
        ii = slice(5 * jj, 5 * (jj + 1))
        arr_fs.append(F_pot[ii])

    # Electron density parameters
    A = 2.591061
    d = 4.076980
    rend = 5

    nr = 5000
    dr = rend / (nr - 1)
    rr = np.arange(0, rend + dr, dr)

    rho_pot = []

    # Compute rho_pot
    for r in rr:
        if r < d:
            rho = A ** 2 * (r - d) ** 2
        else:
            rho = 0
        rho_pot.append(rho)

    # Tabulate rho_pot
    for jj in range(1000):
        ii = slice(5 * jj, 5 * (jj + 1))
        arr_fs.append(rho_pot[ii])

    # Pair-potential parameters
    c = 4.20
    # c0 = 1.2157373
    # c1 = 0.0271471
    c0 = c0_
    c1 = c1_
    # c2 = -0.1217350
    c2 = c2_
    c3 = 0
    c4 = 0

    V_pair = []

    # Compute pair potential
    for r in rr:
        if r < c:
            V = (r - c) ** 2 * (c0 + c1 * r + c2 * r ** 2 + c3 * r ** 3 + c4 * r ** 4)
        else:
            V = 0
        V_pair.append(V)

    pair_pot = np.array(V_pair) * rr

    # Tabulate pair potential
    for jj in range(1000):
        ii = slice(5 * jj, 5 * (jj + 1))
        arr_fs.append(pair_pot[ii])

    # Write to new data file
    data_out_file_name = 'Ta_orig_FS.eam1.alloy'
    with open(data_out_file_name, 'w') as data_out_file_ID:
        dataArray = [
            'Ta2 EAM/FS model',
            'Original finnis and sinclair parameters',
            'Generated by python',
            '1  Ta',
            '5000  2.4962788268074E-02  5000  10.00200040008e-04  0.4200000E+01',
            '73     180.95         3.304    bcc'
        ]

        # Rewrite the first 6 lines
        for line in dataArray:
            data_out_file_ID.write(line + '\n')

        # Write tabulated data
        for k in range(3000):
            data = arr_fs[k]
            str_data = ' '.join(map(str, data))
            data_out_file_ID.write(str_data + '\n')


def dyn_lammps(x1, x2, x3):
    data_exp = np.loadtxt('outputR-2000000.txt', skiprows=9)
    Natoms = data_exp.shape[0]
    exp_cords = []

    for line in range(Natoms):
        atom_id = data_exp[line, 0]
        x = data_exp[line, 2]
        y = data_exp[line, 3]
        z = data_exp[line, 4]
        exp_cords.append([atom_id, x, y, z])

    exp_cords = np.array(exp_cords)

    # somewhere here i need to call in the lammps file
    lmp = lammps()
    write_pair_potential(x1, x2, x3)
    lmp.file('bcc_disc_edge_new.in')
    lmp.close()

    # Read the final equilibrated state of FS potential
    # readfile = 326
    # textFileName = f'output-{readfile}.txt'
    textFileName = 'relaxed_fin.lmp'

    # data = np.loadtxt(textFileName, skiprows=9)
    # data = np.loadtxt(textFileName, skiprows=16)
    # Natoms = data.shape[0]
    Natoms = 8214
    data = np.loadtxt(textFileName, skiprows=16, max_rows=Natoms)

    # embed()

    # Calculate the least square distance
    obj = 0

    for line in range(Natoms):
        atom_id = data[line, 0]
        x = data[line, 2]
        y = data[line, 3]
        z = data[line, 4]

        # Find corresponding experimental coordinates
        idx = np.abs(exp_cords[:, 0] - atom_id) < 1e-5
        x_exp = exp_cords[idx, 1][0]
        y_exp = exp_cords[idx, 2][0]
        z_exp = exp_cords[idx, 3][0]

        # Calculate the objective function
        obj += np.sqrt((x - x_exp) ** 2 + (y - y_exp) ** 2 + (z - z_exp) ** 2)
        # obj /= Natoms

    obj /= Natoms
    return obj

if __name__ == "__main__":
    x1, x2, x3 = read_params_file('params.in')
    # f_val = rosenbrock(x1, x2)
    f_val = dyn_lammps(x1, x2, x3)
    write_results_file('results.out', f_val)



